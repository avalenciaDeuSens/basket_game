<!DOCTYPE html>
<html lang="en">
	<base href="./">
	<head>
		<title>three.js physics - ammo.js instancing</title>
		<meta charset="utf-8">
		<link rel="stylesheet" type="text/css" href="css/styles.css" />
	</head>
	<body>
		<div id="container"></div>

		<script type="text/javascript" src="./js/three.min.js"></script>
		<script type="text/javascript" src="./js/stats.js"></script>
		<script type="module" src="js/OrbitControls.js"></script>
		<script type="text/javascript" src="../physi.js"></script>
		<script type="text/javascript">
		let container, render_stats, physics_stats;
		let camera, controls, scene, renderer;
		let init;
		</script>
		<script type="module">
		import {
			OrbitControls
		} from './js/OrbitControls.js';
		'use strict';		
		let torus;
		Physijs.scripts.worker = '../physijs_worker.js';
		Physijs.scripts.ammo = './examples/js/ammo.js';
			
		let textureLoader;
		const clock = new THREE.Clock();

		const mouseCoords = new THREE.Vector2();
		const raycaster = new THREE.Raycaster();
		const ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );

		const pos = new THREE.Vector3();
		const quat = new THREE.Quaternion();

		// - Main code -

		window.onload = init;


		// - Functions -

		function init() {

			initGraphics();

			createObjects();

			initInput();

		}

		function initGraphics() {

			container = document.getElementById( 'container' );

			camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );

			scene = new Physijs.Scene;
			scene.setGravity(new THREE.Vector3( 0, -9, 0 ));
			scene.addEventListener(
				'update',
				function() {
					scene.simulate( undefined, 2 );
					physics_stats.update();
				}
			);
			camera.position.set( 0, 1, 5 );

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			container.appendChild( renderer.domElement );

			controls = new OrbitControls( camera, renderer.domElement );
			controls.target.set( 0, 2, -5 );
			controls.update();

			textureLoader = new THREE.TextureLoader();

			const ambientLight = new THREE.AmbientLight( 0x707070 );
			scene.add( ambientLight );

			const light = new THREE.DirectionalLight( 0xffffff, 1 );
			light.position.set( - 10, 18, 5 );
			light.castShadow = true;
			const d = 14;
			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;
			
			light.shadow.camera.near = 2;
			light.shadow.camera.far = 50;
			
			light.shadow.mapSize.x = 1024;
			light.shadow.mapSize.y = 1024;

			scene.add( light );

			render_stats = new Stats();
			render_stats.domElement.style.position = 'absolute';
			render_stats.domElement.style.top = '0px';
			render_stats.domElement.style.zIndex = 100;
			document.getElementById( 'container' ).appendChild( render_stats.domElement );
			
			physics_stats = new Stats();
			physics_stats.domElement.style.position = 'absolute';
			physics_stats.domElement.style.top = '50px';
			physics_stats.domElement.style.zIndex = 100;
			document.getElementById( 'container' ).appendChild( physics_stats.domElement );

			//

			window.addEventListener( 'resize', onWindowResize );
			requestAnimationFrame( animate );
			scene.simulate();
		}

		function createObjects() {

			// Ground
			pos.set( 0, - 0.5, 0 );
			quat.set( 0, 0, 0, 1 );
			const ground = createParalellepipedWithPhysics( 10, 1, 10, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
			scene.add(ground);
			ground.receiveShadow = true;
            const wall = createParalellepipedWithPhysics(10,10,1,0,new THREE.Vector3(0,5,-5),quat,new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ));
			scene.add(wall);
			wall.receiveShadow = true;
            const backboard = createParalellepipedWithPhysics(1.8,1.12,0.2,0,new THREE.Vector3(0,3.1,-4.4),quat,new THREE.MeshPhongMaterial( { color: 0xCCCCCC } ));
			scene.add(backboard);
			backboard.receiveShadow = true;			
            const torus = createTorus(0.50, 0.05, new THREE.Vector3(0,2.8,-3.75),quat.setFromEuler(new THREE.Euler(Math.PI/2,0,0,'XYZ')),new THREE.MeshPhongMaterial( { color: 0xCCCCCC } ));
			torus.receiveShadow = true;
			torus.castShadow = true;
			scene.add(torus);
		}

		function createParalellepipedWithPhysics( sx, sy, sz, mass, pos, quat, material ) {
			const object = new Physijs.BoxMesh(  new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material, 0 );
			object.position.copy(pos);
			object.rotation.setFromQuaternion(quat);
			return object;
		}

		function createTorus(extRadius, intRadius, pos, quat, material){
			const fragments = 32;
			torus = new THREE.Mesh(new THREE.TorusGeometry( extRadius, intRadius, fragments, fragments ), material);
			torus.position.copy(pos);
			torus.rotation.setFromQuaternion(quat);
			
			const fragSize = 2 * Math.PI * extRadius/fragments * 1.1;
			const baseVector = new THREE.Vector3(0, 0, extRadius-0.005);
			const yVector = new THREE.Vector3(0,1,0);
			const angle = (2 * Math.PI)/fragments;
			for (let index = 0; index < fragments; index++) {
				let object = new Physijs.CylinderMesh( 
					new THREE.CylinderGeometry( intRadius, intRadius, fragSize, fragments ),
				 	new THREE.MeshPhongMaterial( { color: 0xCCCCCC } ), 0 );
					 object.visible=false;
				let newPos = new THREE.Vector3();
				newPos.copy(pos);
				if(index!=0)
					newPos.add(baseVector.applyAxisAngle(yVector,  angle));
				else
					newPos.add(baseVector);
				object.position.copy(newPos);
				object.rotation.setFromQuaternion(quat.setFromEuler(new THREE.Euler(0,angle * index,Math.PI/2, 0,'XYZ')));
				scene.add(object);
			}
			return torus;
		}

		function createRandomColor() {

			return Math.floor( Math.random() * ( 1 << 24 ) );

		}

		function createMaterial( color ) {

			color = color || createRandomColor();
			return new THREE.MeshPhongMaterial( { color: color } );

		}

		function initInput() {

			window.addEventListener( 'pointerdown', function ( event ) {

				mouseCoords.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1
				);

				raycaster.setFromCamera( mouseCoords, camera );

				// Creates a ball and throws it
				const ballMass = 1;
				const ballRadius = 0.4;

				const ball = new Physijs.SphereMesh(new THREE.SphereGeometry( ballRadius, 14, 10 ),
				ballMaterial, ballMass);
				ball.castShadow = true;
				ball.receiveShadow = true;
				
				pos.copy( raycaster.ray.direction );
				pos.add( raycaster.ray.origin );
				quat.set( 0, 0, 0, 1 );
				ball.position.copy(pos);
				ball.rotation.setFromQuaternion(quat);
				scene.add(ball);

				pos.copy( raycaster.ray.direction );
				pos.multiplyScalar( 24 );
				ball.setLinearVelocity( new THREE.Vector3( pos.x, pos.y, pos.z ) );

			} );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			requestAnimationFrame( animate );

			renderer.render( scene, camera );
			render_stats.update();

		}
		</script>
	</body>
</html>
